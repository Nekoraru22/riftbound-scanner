<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>YOLO OBB Test</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0"></script>
  <style>
    body { background: #111; color: #fff; font-family: monospace; margin: 20px; }
    #canvas-container { position: relative; display: inline-block; }
    canvas { max-width: 640px; }
    #log { white-space: pre-wrap; margin-top: 20px; padding: 10px; background: #222; max-height: 400px; overflow-y: auto; }
    button { padding: 8px 16px; margin: 5px; cursor: pointer; }
    input[type=range] { width: 200px; vertical-align: middle; }
    .controls { margin: 10px 0; }
  </style>
</head>
<body>
  <h2>YOLO11n-OBB Test</h2>
  <div class="controls">
    <input type="file" id="fileInput" accept="image/*">
    <button id="runBtn" disabled>Run Detection</button>
    <br>
    <label>Confidence: <input type="range" id="confSlider" min="0.01" max="0.99" step="0.01" value="0.85">
    <span id="confVal">0.85</span></label>
    &nbsp;
    <label>IoU: <input type="range" id="iouSlider" min="0.1" max="0.9" step="0.05" value="0.45">
    <span id="iouVal">0.45</span></label>
  </div>
  <div id="canvas-container">
    <canvas id="canvas"></canvas>
  </div>
  <div id="crops" style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;"></div>
  <div id="log">Loading model...</div>

<script>
const MODEL_URL = '/models/yolo11n-obb-riftbound/model.json';
const INPUT_SIZE = 640;
let model = null;
let currentImage = null;
let cardDB = null; // { gridSize, cards: [{ id, name, set, f: Float32Array }] }

// --- Card Matcher (color grid + cosine similarity) ---
function computeColorGrid(canvas, gridSize) {
  const tmp = document.createElement('canvas');
  tmp.width = gridSize;
  tmp.height = gridSize;
  tmp.getContext('2d').drawImage(canvas, 0, 0, gridSize, gridSize);
  const data = tmp.getContext('2d').getImageData(0, 0, gridSize, gridSize).data;
  const features = new Float32Array(gridSize * gridSize * 3);
  for (let i = 0, j = 0; i < data.length; i += 4) {
    features[j++] = data[i] / 255;       // R
    features[j++] = data[i + 1] / 255;   // G
    features[j++] = data[i + 2] / 255;   // B
  }
  return features;
}

function cosineSimilarity(a, b) {
  let dot = 0, normA = 0, normB = 0;
  for (let i = 0; i < a.length; i++) {
    dot += a[i] * b[i];
    normA += a[i] * a[i];
    normB += b[i] * b[i];
  }
  const denom = Math.sqrt(normA) * Math.sqrt(normB);
  return denom > 0 ? dot / denom : 0;
}

function rotateCanvas90(canvas) {
  const rot = document.createElement('canvas');
  rot.width = canvas.height;
  rot.height = canvas.width;
  const rctx = rot.getContext('2d');
  rctx.translate(rot.width / 2, rot.height / 2);
  rctx.rotate(Math.PI / 2);
  rctx.drawImage(canvas, -canvas.width / 2, -canvas.height / 2);
  return rot;
}

function identifyCard(cropCanvas) {
  if (!cardDB) return null;
  // Try both orientations and pick the best match
  const featNormal = computeColorGrid(cropCanvas, cardDB.gridSize);
  const rotated = rotateCanvas90(cropCanvas);
  const featRotated = computeColorGrid(rotated, cardDB.gridSize);

  let bestSim = -1, bestCard = null;
  const scores = [];
  for (const c of cardDB.cards) {
    const s1 = cosineSimilarity(featNormal, c.f);
    const s2 = cosineSimilarity(featRotated, c.f);
    const sim = Math.max(s1, s2);
    if (sim > bestSim) { bestSim = sim; bestCard = c; }
    scores.push({ card: c, similarity: sim });
  }
  scores.sort((a, b) => b.similarity - a.similarity);
  return {
    card: bestCard,
    similarity: bestSim,
    top3: scores.slice(0, 3).map(r => ({ name: r.card.name, set: r.card.set, sim: (r.similarity * 100).toFixed(1) })),
  };
}

function cropRotated(img, cx, cy, w, h, angle) {
  // Step 1: Draw full image rotated around the card center onto a large temp canvas
  // so the card appears axis-aligned
  const diag = Math.sqrt(img.width * img.width + img.height * img.height);
  const big = document.createElement('canvas');
  big.width = Math.ceil(diag);
  big.height = Math.ceil(diag);
  const bctx = big.getContext('2d');
  const bcx = big.width / 2;
  const bcy = big.height / 2;
  bctx.translate(bcx, bcy);
  bctx.rotate(-angle);
  bctx.drawImage(img, -cx, -cy);

  // Step 2: Crop the card-sized region from center of the big canvas
  const c = document.createElement('canvas');
  c.width = Math.round(w);
  c.height = Math.round(h);
  c.getContext('2d').drawImage(big, bcx - w / 2, bcy - h / 2, w, h, 0, 0, w, h);

  // Step 3: If landscape, rotate to portrait (cards are portrait by default)
  if (w > h) {
    const rot = document.createElement('canvas');
    rot.width = Math.round(h);
    rot.height = Math.round(w);
    const rctx = rot.getContext('2d');
    rctx.translate(rot.width / 2, rot.height / 2);
    rctx.rotate(Math.PI / 2);
    rctx.drawImage(c, -c.width / 2, -c.height / 2);
    return rot;
  }
  return c;
}

// Load card hashes
async function loadCardHashes() {
  try {
    const resp = await fetch('/card-hashes.json');
    if (!resp.ok) { addLog('Card hashes not found (run hashCards.py first)'); return; }
    const data = await resp.json();
    data.cards.forEach(c => { c.f = new Float32Array(c.f); });
    cardDB = data;
    addLog(`Card DB loaded: ${data.cards.length} cards (${data.gridSize}x${data.gridSize} color grid)`);
  } catch (e) {
    addLog('Could not load card DB: ' + e.message);
  }
}

const log = document.getElementById('log');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const confSlider = document.getElementById('confSlider');
const confVal = document.getElementById('confVal');
const iouSlider = document.getElementById('iouSlider');
const iouVal = document.getElementById('iouVal');
const runBtn = document.getElementById('runBtn');

function addLog(msg) {
  log.textContent += msg + '\n';
  log.scrollTop = log.scrollHeight;
}

confSlider.oninput = () => confVal.textContent = confSlider.value;
iouSlider.oninput = () => iouVal.textContent = iouSlider.value;

// Load model
async function loadModel() {
  try {
    model = await tf.loadGraphModel(MODEL_URL);
    addLog('Model loaded OK');

    // Warmup
    const dummy = tf.zeros([1, INPUT_SIZE, INPUT_SIZE, 3]);
    const warmup = model.predict(dummy);
    const shape = warmup.shape;
    addLog(`Output shape: [${shape}]`);
    warmup.dispose();
    dummy.dispose();

    runBtn.disabled = false;
    addLog('Ready. Select an image and click Run Detection.');
  } catch (e) {
    addLog('ERROR loading model: ' + e.message);
  }
}

// Load image
document.getElementById('fileInput').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const img = new Image();
  img.onload = () => {
    currentImage = img;
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);
    addLog(`Image loaded: ${img.width}x${img.height}`);
  };
  img.src = URL.createObjectURL(file);
});

// Run detection
runBtn.addEventListener('click', async () => {
  if (!model || !currentImage) return;
  runBtn.disabled = true;

  const confThreshold = parseFloat(confSlider.value);
  const iouThreshold = parseFloat(iouSlider.value);
  addLog(`\nRunning detection (conf=${confThreshold}, iou=${iouThreshold})...`);

  const t0 = performance.now();

  // Letterbox preprocess (maintain aspect ratio, pad with gray)
  const imgW = currentImage.width;
  const imgH = currentImage.height;
  const scale = Math.min(INPUT_SIZE / imgW, INPUT_SIZE / imgH);
  const newW = Math.round(imgW * scale);
  const newH = Math.round(imgH * scale);
  const padX = (INPUT_SIZE - newW) / 2;
  const padY = (INPUT_SIZE - newH) / 2;

  addLog(`Letterbox: scale=${scale.toFixed(4)}, newSize=${newW}x${newH}, pad=(${padX.toFixed(1)},${padY.toFixed(1)})`);

  const tensor = tf.tidy(() => {
    let img = tf.browser.fromPixels(currentImage);
    img = tf.image.resizeBilinear(img, [newH, newW]);
    img = img.toFloat().div(255.0);
    // Pad to INPUT_SIZE x INPUT_SIZE
    const padTop = Math.floor(padY);
    const padBottom = INPUT_SIZE - newH - padTop;
    const padLeft = Math.floor(padX);
    const padRight = INPUT_SIZE - newW - padLeft;
    img = tf.pad(img, [[padTop, padBottom], [padLeft, padRight], [0, 0]], 0.4470588); // 114/255
    return img.expandDims(0);
  });

  // Inference
  const predictions = model.predict(tensor);
  tensor.dispose();

  const outputData = await predictions.data();
  const shape = predictions.shape;
  predictions.dispose();

  const t1 = performance.now();
  addLog(`Inference: ${(t1 - t0).toFixed(1)}ms, output shape: [${shape}]`);

  // Parse detections based on shape
  const detections = [];
  const numChannels = shape[1]; // 6
  const numDets = shape[2];     // 8400

  addLog(`Parsing ${numDets} candidates (${numChannels} channels)...`);

  // Log raw value ranges for debugging
  for (let ch = 0; ch < numChannels; ch++) {
    let min = Infinity, max = -Infinity;
    for (let i = 0; i < numDets; i++) {
      const v = outputData[ch * numDets + i];
      if (v < min) min = v;
      if (v > max) max = v;
    }
    addLog(`  ch${ch}: min=${min.toFixed(4)}, max=${max.toFixed(4)}`);
  }

  for (let i = 0; i < numDets; i++) {
    // Channel 4 = class score (already sigmoid in model), Channel 5 = angle (already radians)
    const conf = outputData[4 * numDets + i];
    if (conf >= confThreshold) {
      // Map from letterbox 640x640 space back to original image coords
      const rawCx = outputData[0 * numDets + i];
      const rawCy = outputData[1 * numDets + i];
      const rawW  = outputData[2 * numDets + i];
      const rawH  = outputData[3 * numDets + i];
      detections.push({
        cx: (rawCx - padX) / scale,
        cy: (rawCy - padY) / scale,
        w:  rawW / scale,
        h:  rawH / scale,
        angle: outputData[5 * numDets + i],
        conf,
      });
    }
  }

  addLog(`Detections above threshold: ${detections.length}`);

  // NMS (now in original image coords)
  detections.sort((a, b) => b.conf - a.conf);
  const kept = [];
  for (const det of detections) {
    let dominated = false;
    for (const k of kept) {
      const ix1 = Math.max(det.cx - det.w/2, k.cx - k.w/2);
      const iy1 = Math.max(det.cy - det.h/2, k.cy - k.h/2);
      const ix2 = Math.min(det.cx + det.w/2, k.cx + k.w/2);
      const iy2 = Math.min(det.cy + det.h/2, k.cy + k.h/2);
      const inter = Math.max(0, ix2-ix1) * Math.max(0, iy2-iy1);
      const union = det.w*det.h + k.w*k.h - inter;
      if (union > 0 && inter/union > iouThreshold) { dominated = true; break; }
    }
    if (!dominated) kept.push(det);
  }

  addLog(`After NMS: ${kept.length} detections`);

  // Draw (coordinates are already in original image space)
  ctx.drawImage(currentImage, 0, 0);

  // Clear crop debug area
  const cropsDiv = document.getElementById('crops');
  cropsDiv.innerHTML = '';

  for (let idx = 0; idx < kept.length; idx++) {
    const det = kept[idx];
    const cx = det.cx;
    const cy = det.cy;
    const w = det.w;
    const h = det.h;
    const angle = det.angle;

    // Identify card via color grid matching
    let label = `${(det.conf * 100).toFixed(1)}%`;
    const crop = cropRotated(currentImage, cx, cy, w, h, angle);
    const match = identifyCard(crop);

    // Show crop for debugging
    const cropPreview = document.createElement('div');
    cropPreview.style.cssText = 'text-align:center; font-size:11px;';
    const preview = document.createElement('canvas');
    const pH = 150;
    const pW = Math.round(pH * crop.width / crop.height);
    preview.width = pW; preview.height = pH;
    preview.getContext('2d').drawImage(crop, 0, 0, pW, pH);
    preview.style.border = '1px solid #0f0';
    cropPreview.appendChild(preview);
    cropPreview.appendChild(document.createTextNode(
      `#${idx+1} ${match ? match.top3[0].name : '?'}`
    ));
    cropsDiv.appendChild(cropPreview);
    if (match) {
      const top = match.top3.map(t => `${t.name}[${t.set}] ${t.sim}%`).join(' | ');
      addLog(`  #${idx + 1} top3: ${top}`);
      if (match.similarity > 0.55) {
        label = `${match.card.name} (${(match.similarity * 100).toFixed(0)}%)`;
      }
    }

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(angle);
    ctx.strokeStyle = `rgba(0, 255, 0, ${Math.min(1, det.conf + 0.3)})`;
    ctx.lineWidth = 3;
    ctx.strokeRect(-w/2, -h/2, w, h);
    // Label background
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    const textW = ctx.measureText(label).width + 8;
    ctx.fillRect(-w/2, -h/2 - 22, textW, 20);
    ctx.fillStyle = 'rgba(0, 255, 0, 0.9)';
    ctx.font = '14px monospace';
    ctx.fillText(label, -w/2 + 4, -h/2 - 6);
    ctx.restore();
  }

  runBtn.disabled = false;
});

loadModel();
loadCardHashes();
</script>
</body>
</html>
